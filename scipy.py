# -*- coding: utf-8 -*-
"""scipy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FZTD9BiO9jNMNi19q5Ng5e5Ddt_PjfzH
"""

import scipy

print(scipy.__version__)

"""**SciPy**

- SciPy is a scientific computation library that uses NumPy underneath.
- SciPy stands for Scientific Python.
- It provides more utility functions for optimization, stats and signal processing.
- Like NumPy, SciPy is open source so we can use it freely.
- SciPy was created by NumPy's creator Travis Olliphant.



**Language is SciPy Written In**

SciPy is predominantly written in Python, but a few segments are written in C.

**Installation of SciPy**

`pip install scipy`


**Constants:** Scipy offers a set of mathematical constants, one of them is **liter** which returns 1 liter as cubic meters.

**Note:** Two underscore characters are user in `__version__`.
"""

from scipy import constants
import scipy

print(constants.liter)

print(scipy.__version__)

"""**Constants**

As SciPy is more focused on scientific implementations, it provides many build-in scientific constants.


"""

from scipy import constants
print(constants.pi)
print(dir(constants))
print(constants.yotta)
print(constants.zetta)
print(constants.exa)
print(constants.peta)
print(constants.tera)
print(constants.giga)
print(constants.mega)
print(constants.kilo)
print(constants.hecto)
print(constants.deka)
print(constants.deci)
print(constants.centi)
print(constants.milli)
print(constants.micro)
print(constants.nano)
print(constants.pico)
print(constants.femto)
print(constants.atto)
print(constants.zepto)

"""**Binary Prefixes**

Return the specified unit in bytes(e.g. kibi returns 1024)

"""

from scipy import constants

print(constants.kibi)
print(constants.mebi)
print(constants.gibi)
print(constants.tebi)
print(constants.pebi)
print(constants.exbi)
print(constants.zebi)
print(constants.yobi)

"""**Mass**

Return the specified unit in kg(e.g. gram returns 0.001)

"""

from scipy import constants

print(constants.gram)
print(constants.metric_ton)
print(constants.grain)
print(constants.lb)
print(constants.pound)
print(constants.oz)
print(constants.ounce)
print(constants.stone)
print(constants.long_ton)
print(constants.short_ton)
print(constants.troy_ounce)
print(constants.carat)
print(constants.atomic_mass)
print(constants.m_u)
print(constants.u)

"""**Angle**

Return the specified in radians(e.g. degree returns 0.017453292519943295)
"""

from scipy import constants

print(constants.degree)
print(constants.arcmin)
print(constants.arcmin)
print(constants.arcsec)
print(constants.arcsecond)

"""**Time**

Return the specified unit in seconds(e.g. hour returns 3600.0)
"""

from scipy import constants

print(constants.minute)
print(constants.hour)
print(constants.day)
print(constants.week)
print(constants.year)
print(constants.Julian_year)

"""**Length**

Return the specified unit in meters(e.g. nautical_mile returns 1852.0)

"""

from scipy import constants

print(constants.inch)
print(constants.foot)
print(constants.yard)
print(constants.mile)
print(constants.mil)
print(constants.pt)
print(constants.point)
print(constants.survey_foot)
print(constants.survey_mile)
print(constants.nautical_mile)
print(constants.fermi)
print(constants.angstrom)
print(constants.micron)
print(constants.au)
print(constants.astronomical_unit)
print(constants.light_year)
print(constants.parsec)

"""**Pressure**

Return the specified unit in pascals (e.g. psi rturns 6894.757293168361)
"""

from scipy import constants

print(constants.atm)
print(constants.atmosphere)
print(constants.bar)
print(constants.torr)
print(constants.mmHg)
print(constants.psi)

"""**Area**

Return the specified unit in square meters (e.g. hectare returns 10000.0)
"""

from scipy import constants

print(constants.hectare)
print(constants.acre)

"""**Volume**

Return the specified unit in cubic meters (e.g. liter returns 0.001)

"""

from scipy import constants

print(constants.liter)
print(constants.gallon)
print(constants.gallon_US)
print(constants.gallon_imp)
print(constants.fluid_ounce)
print(constants.fluid_ounce_US)
print(constants.fluid_ounce_imp)
print(constants.barrel)
print(constants.bbl)

"""**Speed**

Return the specified unit in meters per second (e.g. speed_of_sound returns 340.5)
"""

from scipy import constants

print(constants.kmh)
print(constants.mph)
print(constants.mach)
print(constants.speed_of_sound)
print(constants.knot)

"""**Temperature**

Return the specified unit in Kelvin(e.g. zero_Celsius return 273.15)

"""

from scipy import constants

print(constants.zero_Celsius)
print(constants.degree_Fahrenheit)

"""**Energy**

Return the specified unit in Joules(e.g. calorie returns 4.184)
"""

from scipy import constants

print(constants.eV)
print(constants.electron_volt)
print(constants.calorie)
print(constants.calorie_th)
print(constants.calorie_IT)
print(constants.erg)
print(constants.Btu)
print(constants.Btu_IT)
print(constants.Btu_th)
print(constants.ton_TNT)

"""**Power**

Return the specified unit in watts(e.g. horsepower returns 745.6998715822701 )
"""

from scipy import constants

print(constants.hp)
print(constants.horsepower)

"""**Force**

Return the specified unit in newton (e.g. kilogram_force return 9.80665)

"""

from scipy import constants

print(constants.dyn)
print(constants.dyne)
print(constants.lbf)
print(constants.pound_force)
print(constants.kgf)
print(constants.kilogram_force)

"""**Optimizers**

Optimizers are a set of procedures defined in Scipy that either find the minimum value of a function, or the root of an equation.

**Roots of an equation**

NumPy is capable of finding in Machine Learning are nothing more than a complex equation that needs to be minimized with the help of given data.

**Root of an Equation**

NumPy is capable of finding roots for polynomials and linear equations, but it can find roots for non linear equations, like this one:

`x + cos(x)`

- For that you can use SciPy's optimize.root function.
- This function takes two required arguments
- *fun* - a function representing an equation.
- *x0* - an initial guess for the root.

The function returns an returns an object with information regarding the solution.

The actual solution is given under attribut x of the returned object.
"""

from scipy.optimize import root
from math import cos

def eqn(x):
  return x+cos(x)

myroot = root(eqn,0)

print(myroot.x)

"""**Minimizing a function**

A function, in this context, represents a curve, curves have high points and low points.

High points are called maxima.

Low points are called minima.

The highest point in the whole curve is called global maxima, whereas the rest of them are called local maxima.

The lowest point in whole curse is called global minima, whereas, whereas the rest of them are called local minima.



**Finding Minima**

We can use scipy.optimize.minimize()  function to minimize the function.

The minimize() function  takes the following arguments:

- fun  - a function representing an equation.
- x0 - an initial guess for the root.
- method - name of the method to use. Legal value:

`CG`

`BFGS`

`Newton-CG`

`L-BFGS-B`

`TNC`

`COBYLA`

`SLSQP`

*-callback* - function called after each iteration of optimization.

*-options* - a dictionary defining extra params:


"""

from scipy.optimize import minimize

def eqn(x):
  return x ** 2 + x + 2

mymin = minimize(eqn,0,method='BFGS')

print(mymin)

"""*Spare Data*

Sparse data is data that has mostly unused elements.

It can be an array like this one

[1,0,2,0,3,0,0,0,0,0,0]

*Spare Data:* is a data set where most of the item values are zero.

*Dense Array:* is the opposite of a sparse array: most of the values are not zero.


- SciPy has a module, scipy.sparese that provides functions to deal with sparse data.
- There are primarily two types of sparse matrices that we use
-*CSC -* Compressed Sparse column. For efficient arithmetic, fast column slicing.
- *CSR -* Compressed Sparse Row. For fast row slicing, faster matrix vector products.

We will use the CSR matrix in this tutorial.


*CSR Matrix*

We can create CSR matrix by passing an array into function scipy.sparse.csr_matrix().


"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([0, 0, 0, 0, 0, 1, 1, 0, 2])

print(csr_matrix(arr))

"""*Sparse Matrix Methods*

Viewing stored data with the data property
"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])
print(csr_matrix(arr).data)

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0,0,0],[0,0,1],[1,0,2]])
print(csr_matrix(arr).count_nonzero())

"""Removing zero-entries from the matrix with the `eliminate_zeros()` methods"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0,0,0],[0,0,1],[1,0,2]])

mat = csr_matrix(arr)
mat.eliminate_zeros()

print(mat)

"""Eliminating duplicate entries with the `sum_duplicates()` method"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

mat = csr_matrix(arr)
mat.sum_duplicates()

print(mat)

"""Converting from csr to csc with `tocsc()` method

*Note-* Apart from the mentioned sparse specific operations, sparse matrices support all of the operations that normal matrices suppor reshaping, summing, arithemetic, broadcasting etc.
"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([[0,0,0],[0,0,1],[1,0,2]])
newarr = csr_matrix(arr).tocsc()
print(newarr)

"""***Graphs***

Graphs are an essential data structure.

SciPy provides us with the module scipy.sparse.csgraph for working with such data structures.

**Adjacency Matrix**

Ajacency matrix is a nxn matrix where n is the number of elements in a graph.

And the values represents the connection between elements.

      A
     /   \
    /     \
    B     C
  

  - A & B are connected with 1.
  - A & C are connected with weight 2.
  - C & B is not connected.

  
**Connencted Components**

Find all of the connected components with the connected_components() method.
"""

import numpy as np
from scipy.sparse.csgraph import connected_components
from scipy.sparse import csr_matrix

arr = np.array([
    [0,1,2],
    [1,0,0],
    [2,0,0]
])

newarr = csr_matrix(arr)
print(connected_components(newarr))

"""**Dijkstra**

Use the dijkstra method to find the shortest path in a graph from one element to another.

It takes following arguments

1. **return_predecessors:** boolean
2. **indices:** index of the element to return all paths from the element only.
3. **limit:** max weight of path
"""

import numpy as np
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix

arr = np.array([
    [0,1,2],
    [1,0,0],
    [2,0,0]
])

newarr = csr_matrix(arr)
print(dijkstra(newarr,return_predecessors=True,indices=0))

"""**Floyd Warshall**

Use the floyd_warshall() method to find shortest path between all pairs of elements.
"""

import numpy as np
from scipy.sparse.csgraph import floyd_warshall
from scipy.sparse import csr_matrix

arr = np.array([
    [0,1,2],
    [1,0,0],
    [2,0,0]
])

newarr = csr_matrix(arr)
print(floyd_warshall(newarr, return_predecessors=True))

"""**Bellman Ford**

The bellman_ford() method can also find the shortest path between all pairs of elements, but this method can handle negative weights as well.

"""

import numpy as np
from scipy.sparse.csgraph import bellman_ford
from scipy.sparse import csr_matrix

arr = np.array([
    [0,-1,2],
    [1,0,0],
    [2,0,0]
])

newarr = csr_matrix(arr)
print(bellman_ford(newarr,return_predecessors=True,indices=0))

"""**Depth First Order**

The depth_first_order()  method returns a depth first traversal from a node.

This function takes following arguments

1. the graph.
2. the starting element to traverse graph from.
"""

import numpy as np
from scipy.sparse.csgraph import depth_first_order
from scipy.sparse import csr_matrix

arr = np.array([
    [0,1,0,1],
    [1,1,1,1],
    [2,1,1,0],
    [0,1,0,1]
])

newarr = csr_matrix(arr)
print(depth_first_order(newarr,1))

"""**BReath Firsth Order**

The breadth_first_order() method returns a breadth first traversal from a node.

This function takes following arguments:
1. The graph.
2. The starting element to raverse graph from .
"""

import numpy as np
from scipy.sparse.csgraph import breadth_first_order
from scipy.sparse import csr_matrix

arr = np.array([
    [0,1,0,1],
    [1,1,1,1],
    [2,1,1,0],
    [0,1,0,1]
])

newarr = csr_matrix(arr)
print(breadth_first_order(newarr,1))

"""**Triangulation**

A triangulation of a polygon is to divide the polygon into multiple triangles with which we can compute an area of the polygon.

A Triangulation with points  means creating surface composed triangles in which all of the given points are on at least one vertex of any triangle in the surface.

One method to generate these triangulations through points in the Delaunay() Triangulation.
"""

import numpy as np
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

points = np.array([
  [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1]
])

simplices = Delaunay(points).simplices

plt.triplot(points[:, 0], points[:, 1], simplices)
plt.scatter(points[:, 0], points[:, 1], color='r')

plt.show()

"""**Convex Hull**

A convex hull is the smallest polygon that covers all of the given points.

Use the ConvexHull() method to create a Convex Hull.
"""

import numpy as np
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt

points = np.array([
    [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1],
  [1, 2],
  [5, 0],
  [3, 1],
  [1, 2],
  [0, 2]
])

hull = ConvexHull(points)
hull_points = hull.simplices

plt.scatter(points[:,0],points[:,1])
for simplex in hull_points:
  plt.plot(points[simplex,0],points[simplex,1],'k-')
plt.show()

"""**KDTrees**

KDTrees are a datastructure optimized for newarest neighbor queries.

E.g. in a set of points using KDTrees we can efficiently ask which points are nearest to a certain given point.

The KDTree() method returns a KDTree object.

The query() method returns the distance to the nearest neighbor and the location of the neighbors.


"""

from scipy.spatial import KDTree

points = [(1, -1), (2, 3), (-2, 3), (2, -3)]
kdtreee = KDTree(points)
res = kdtreee.query((1,1))
print(res)

"""**Distance Matrix**

There are many distance metrics used to find various types of distances between two points in data science, Euclidean distsance, cosine distance etc.

The distance between two vectors may not only be the length of straight line between them, it can also be the angle between them from origin, or number of unit steps required etc.

Many of the Machine Learning algorithm's performance depends greatly on distance metrics.

**Euclidean Distance**

Find the euclidean distance between given points.


"""

from scipy.spatial.distance import euclidean

p1 = (1,0)
p2 = (10,2)

res = euclidean(p1,p2)
print(res)

"""**Cityblock Distance**

Is the distance computed using 4 degrees of movement.

"""

from scipy.spatial.distance import cityblock

p1 = (1,0)
p2 = (10,2)

res = cityblock(p1,p2)

print(res)

"""**Cosine Distance**

Is the value of cosine angle between the two points A and B
"""

from scipy.spatial.distance import cosine

p1 = (1,0)
p2 = (10,2)

res = cosine(p1,p2)
print(res)

"""**Hamming Distance**

Is the proportion of bits where two bits are different.

It's a way to measure distance for binary sequences.

"""

from scipy.spatial.distance import hamming

p1 = (True, False, True)
p2 = (False, True, True)

res = hamming(p1,p2)
print(res)

"""**Matlab Arrays**

Scipy provides us with the module scipy.io, which has functions for working with matlab arrays.


**Exporting Data in Matlab Format**

The `savemat()` function allows us to export data in matlab format.

1. filename - the file name for saving data.
2. mdict - a dictionary containing the data.
3. do_compression- a boolean value that specifies whether to compress the result or not. Default False.


Note: The example below saves a file name "arr.mat" on your computer.

To open the file, check out the "Import data from matlab format" exmple below.
"""

from scipy import io
import numpy as np

arr = np.arange(10)

io.savemat('arr.mat',{"vec":arr})

print(arr)

"""**Import Data from Matlab Format**

The `loadmat()` function allows us to import data from a Matlab file.

The function takes one required parameter:

**filename -** the file name of the saved data.


"""

from scipy import io
import numpy as np

arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9,])

io.savemat('arr.mat', {"vec": arr})

mydata = io.loadmat('arr.mat')

print(mydata)

"""**Interpolation**

Interpolation is a method for generating points between given points.

Interpolation has many usage, in Machine Learning we ofter deal with missing data in a dataset, interpolation is often used to substitute those values.

This method of filling values is called imputation.

Apart from imputation, interpolation is often used where we need to smooth the descrete pints in a dataset.


**!D Interpolation**

The function `interp1d()` is used to interpolate a distribution with 1 variable.

It takes x and y points and returns a callable function that can be called with new x and return corresponding y.


"""

from scipy.interpolate import interp1d
import numpy as np

xs = np.arange(10)
ys = 2 * xs + 1

interp_func = interp1d(xs,ys)

newarr = interp_func(np.arange(2.1,3,0.1))

print(newarr)

"""**Note:** That new xs should be in same range as of the old xs, meaning that we can't call `interp_func()` with values higher than 10 or less than 0.

**Spline Interpolation**

In 1D interpolation the points are fitted for a single curve whereas in Spline interpolation the points are fitted against a piecewise function defined with polynomials called splines.

The `UnivariateSpline()` function takes xs and ys and produce a callable function that can be called with new xs.


*Piecewise function:** A function that has different definition for different ranges.
"""

from scipy.interpolate import UnivariateSpline
import numpy as np

xs = np.arange(10)
ys = xs**2 + np.sin(xs) + 1

interp_func = UnivariateSpline(xs, ys)

newarr = interp_func(np.arange(2.1, 3, 0.1))

print(newarr)

"""**Interpolation with Radial Basis Function**

Radial basis function is a function that is defined corresponding to a fixed reference point.

The `Rbf()` function also takes xs and ys as arguments and produces a callable function that can be called with new xs.
"""

from scipy.interpolate import Rbf
import numpy as np

xs = np.arange(10)
ys = xs**2 + np.sin(xs) + 1

interp_func = Rbf(xs, ys)

newarr = interp_func(np.arange(2.1, 3, 0.1))

print(newarr)

"""**Statistical Significance Test**

In statistics, statistical significance means that the result that was produced has a reason behind it, it was not produced randomly or by chance.

SciPy provides us with a module called `scipy.stats` which has functions for performing statistical significance tests.



**T-Test**

T-tests are used to determine if there is significant deference between means of two variables and lets us know if they belong to the same distribution.


The function `ttest_ind()` takes two samples of same size and produces a tuple of t-statistic and p-value.
"""

import numpy as np
from scipy.stats import ttest_ind

v1 = np.random.normal(size=100)
v2 = np.random.normal(size=100)

res = ttest_ind(v1,v2)

print(res)

res = ttest_ind(v1,v2).pvalue
print(res)

"""**KS-Test**

KS test is used to check if given values follow a distribution.

The function takes the value to be tested and the CDF as two paramters.

**A CDF can be either a string or a callable function that returns the probability.**


"""

import numpy as np
from scipy.stats import kstest

v = np.random.normal(size=100)

res = kstest(v,'norm')

print(res)

"""**Statistical Description of Data**


In order to see a summary of values in an array, we can use the `describe()` function.

1. number of observations
2. minimum and maximum values = minmax
3. mean
4. variance
5. skewness
6. kurtosis
"""

import numpy as np
from scipy.stats import describe

v = np.random.normal(size=100)
res = describe(v)

print(res)

"""**Normality Tests**

Normality tests are based on the skewnewss and kurtosis.

The normaltest() functino returns p value for the null hypothesis.

**Skewness**

- A measure of symmetry in data.
- For normal distributions it is 0.
- If it is negative, it means the data is skewed left.
- If it is positive it means the data is skewed right.


**Kurtosis**

A measure of whether the data is heavy or lightly tailed to a normal distribution.

Positive kurotsis means heay tailed.

Negative kurtosis means lightly tailed.

"""

import numpy as np
from scipy.stats import skew, kurtosis

v = np.random.normal(size=100)

print(skew(v))
print(kurtosis(v))